




pacman -S mingw64/mingw-w64-x86_64-lld








place.it:
	New C++ Defines for executables:
		WISH_BUILD_PACKAGE
		WISH_ENABLE_RESOURCE_MAPPING
		WISH_PATH_TO_CURRENT_SOURCE
		WISH_PATH_TO_SOURCE

	New build type "package"
		only use for package_* targets to create the packages
		sets up the change_current_path
		sets up the resource mapping






runtime stuffy
	folder change from binary to source
	when to active the resource mapping macro


# ? ! error if resource file is missing at configure time



cmake -B build/dev .
cmake -B build/dev . \
    -DWISH_BUILD_VERSION_MAJOR="0" \
    -DWISH_BUILD_VERSION_MINOR="0" \
    -DWISH_BUILD_VERSION_PATCH="0" \
    -DWISH_BUILD_VERSION_NAME="version-name" \
    -DWISH_BUILD_VARIANT="development" \
    -DWISH_BUILD_NUMBER="0" \
    -DWISH_BUILD_DATETIME="2000-01-01T00:00:00Z" \
    -DWISH_BUILD_UUID="00000000-0000-0000-0000-000000000000"
cmake --build build/dev --target sandbox_versions
cmake --build build/dev --target package_sandbox_versions
cmake --install build/dev --prefix . --component sandbox_versions



# -------------------------------------------------------------------------------------------------



Packaging / Resource
	Packaging and Resource mapping is two separate concepts
		and there might be a third Resource "import/preprocess"

	Resource mapping (Always happens):
		- Defining resource files and their
			build (aka dev) location and
			runtime location
		- Injecting these mapping into to source both at
			build (aka dev) time and
			runtime time

	Packaging (Only happens during packaging)
		Grabbing resource files and placing them into a folder
		From the code always use the desired locations and rely on mapping
		Mapping in release runtime is a noop
		Release runtime ?!= ?== Release build type

	Resource "import/preprocess"

	Alternative approach:
		runtime map, special flag to export, use exported map to package


actual packaging:
	CPACK https://cmake.org/cmake/help/book/mastering-cmake/chapter/Packaging%20With%20CPack.html


# =================================================================================================


include ext targets via cmake when they have support for it

TODO P3: wish: add support for skipping library build/links via directly amending the sources of a dependency (only for DEV build)
TODO P3: wish: Implement a single file or line bootstrap (FetchContent)

TODO P4: wish: Use a shared ext folder (set via an option, default to project/ext) (external folders must be unique based on every used external argument)
TODO P4: wish: Last chance for conan (wish is created even if conan can be used)

TODO P4: wish: inheritance for wish_create_executable and create_library
TODO P5: wish: flag or build options to turn on/off sanitizes
TODO P5: wish: Recommend or easily produce somehow the configure flags:
		-G"Ninja" -DCMAKE_BUILD_TYPE=DEV -DSKIP_EXTERNAL_CONFIGURES=TRUE -DFORCE_COLORED_OUTPUT=TRUE

color diag is solved with CMake 3.24
	https://gitlab.kitware.com/cmake/cmake/-/merge_requests/6990?utm_source=product&utm_medium=link&utm_campaign=CL&utm_content=2022.2
	read into it and remove the relavant wish features



TODO: Error message for: Requested Wish version is not a valid version identifier, please check github/releases or tags for more info

		file(DOWNLOAD <my-url> ${CMAKE_CURRENT_BINARY_DIR}/<filename>
		  STATUS DOWNLOAD_STATUS
		)
		# Separate the returned status code, and error message.
		list(GET DOWNLOAD_STATUS 0 STATUS_CODE)
		list(GET DOWNLOAD_STATUS 1 ERROR_MESSAGE)
		# Check if download was successful.
		if(${STATUS_CODE} EQUAL 0)
		  message(STATUS "Wish: Download completed successfully!")
		else()
		  # Exit CMake if the download failed, printing the error message.
		  message(FATAL_ERROR "Error occurred during download: ${ERROR_MESSAGE}")
		endif()


--- Install ---

include(GNUInstallDirs)
install(TARGETS Example) # Since 3.14 defaults are fine

set(CMAKE_INSTALL_RPATH $ORIGIN)

install(TARGETS Example
	RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR} COMPONENT ${project_name}_Runtime
	LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR} COMPONENT ${project_name}_Runtime
		NAMELINK_COMPONENT Development
	ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR} COMPONENT ${project_name}_Development
)



--- Articles ------------------------------------------------------------------------------------

CppNow 2022: CMake 2022 C++ Modules and More - Bill Hoffman: https://www.youtube.com/watch?v=hkefPcWySzI
CppNow 2021: CMake: One Tool To Build Them All - Bill Hoffman: https://www.youtube.com/watch?v=wULu83jQmIQ
CppCon 2019: Deep CMake for Library Authors - Craig Scott https://www.youtube.com/watch?v=m0DwB4OvDXk
C++Now 2017: Effective CMake - Daniel Pfeifer: https://www.youtube.com/watch?v=bsXLMQ6WgIk

